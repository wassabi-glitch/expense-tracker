from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from .. import oauth2
from .. import models, schemas, utils
from ..session import get_db

router = APIRouter(
    prefix="/users",  # This means you don't have to type "/expenses" in every route!
    tags=['Users']    # This groups them nicely in your /docs page
)


@router.post("/sign-up", response_model=schemas.UserOut, status_code=status.HTTP_201_CREATED)
def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    # 1. Check if user already exists
    db_user = db.query(models.User).filter(
        models.User.email == user.email).first()
    if db_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    db_username = db.query(models.User).filter(
        models.User.username == user.username).first()
    if db_username:
        raise HTTPException(status_code=409, detail="Username already taken")

    # 2. Hash the password using our utility
    hashed_pwd = utils.hash_password(user.password)

    # 3. Create the user object
    new_user = models.User(
        username=user.username,
        email=user.email,
        hashed_password=hashed_pwd
    )

    # 4. Save to Database
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Email or username already registered",
        )
    db.refresh(new_user)  # Get the ID generated by Postgres
    return new_user


@router.post('/sign-in')
def login(user_credentials: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):

    # 1. Try to find the user in the DB
    user = db.query(models.User).filter(
        models.User.email == user_credentials.username).first()

    # 2. If user doesn't exist or password is wrong, throw a 403
    if not user:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, detail="Invalid Credentials")

    if not utils.verify_password(user_credentials.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, detail="Invalid Credentials")

    # 3. Create the token
    access_token = oauth2.create_access_token(data={"user_id": user.id})

    # 4. Return the token
    return {"access_token": access_token, "token_type": "bearer"}
